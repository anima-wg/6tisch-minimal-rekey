---
title: Minimal Security Framework for 6TiSCH
# abbrev: 6tisch-minimal-security
docname: draft-ietf-6tisch-minimal-security-01

# stand_alone: true

ipr: trust200902
area: Internet
wg: 6TiSCH Working Group
kw: Internet-Draft
cat: std

coding: us-ascii
pi: [toc, softrefs, symrefs]

author:
      -
        ins: M. Vucinic
        name: Malisa Vucinic
        org: Inria
        email: malisa.vucinic@inria.fr
        street: 2 Rue Simone Iff
        city: Paris
        code: 75012
        country: France
      -
        ins: J. Simon
        name: Jonathan Simon
        org: Linear Technology
        email: jsimon@linear.com
        street: 32990 Alvarado-Niles Road, Suite 910
        city: Union City, CA
        code: 94587
        country: USA
      -
        ins: K. Pister
        name: Kris Pister
        org: University of California Berkeley
        email: pister@eecs.berkeley.edu
        street: 512 Cory Hall
        city: Berkeley, CA
        code: 94720
        country: USA

normative:

  RFC2119:
  RFC7252:
  RFC7049:
  I-D.ietf-cose-msg:
  I-D.ietf-core-object-security:

informative:
  RFC7554:
  RFC6775:
  RFC6347:
  RFC5869:
  RFC4231:
  RFC7721:
  I-D.ietf-6tisch-minimal:
  I-D.ietf-6tisch-6top-protocol:
  I-D.ietf-6tisch-terminology:
  I-D.selander-ace-cose-ecdhe:
  IEEE8021542015:
    title: "IEEE Std 802.15.4-2015 Standard for Low-Rate Wireless Personal Area Networks (WPANs)"
    author:
      ins: "IEEE standard for Information Technology"
    date: 2015


--- abstract

This draft describes the minimal mechanisms required to support secure
initial configuration in a device being added to a 6TiSCH network.
The goal of this configuration is to set link-layer keys, and to establish a
secure session between each joining node and the JCE who may use that to
further configure the joining device.
Additional security behaviors and mechanisms may be added on top of this minimal framework.

--- middle

# Introduction        {#problems}

When a previously unknown device seeks admission to a 6TiSCH
{{RFC7554}} network (to "join"), it first needs to synchronize to the
network.  The device then configures its IPv6 address and
authenticates itself, and also validates that it is joining the right
network.  At this point it can expect to interact with the network to
configure its link-layer keying material.  Only then may the node
establish an end-to-end secure session with an Internet host using
DTLS {{RFC6347}} or OSCOAP {{I-D.ietf-core-object-security}}.  Once the
application requirements are known, the device interacts with its
peers to request additional resources as needed, or to be
reconfigured as the network changes {{I-D.ietf-6tisch-6top-protocol}}.

This document describes the mechanisms comprising a minimal feature
set for a device to join a 6TiSCH network, up to the point where it
can establish a secure session with an Internet host.

It presumes a network as described by {{RFC7554}},
{{I-D.ietf-6tisch-6top-protocol}}, and {{I-D.ietf-6tisch-terminology}}.
It assumes the joining device pre-configured with either a:

* pre-shared key (PSK),
* raw public key (RPK),
* or a locally-valid certificate and a trust anchor.

As the outcome of the join process, the joining device expects one or
more link-layer key(s) and optionally a temporary network identifier.

# Terminology          {#Terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in {{RFC2119}}. These words
may also appear in this document in lowercase, absent their normative meanings.

The reader is expected to be familiar with the terms and concepts defined in
{{I-D.ietf-6tisch-terminology}}, {{RFC7252}},
{{I-D.ietf-core-object-security}}, and
{{!I-D.ietf-anima-bootstrapping-keyinfra}}.  The following terms are
imported: drop ship, imprint, enrollment, pledge, join proxy, ownership
voucher, join registrar/coordinator.

pledge
:  the prospective device, which has the identity provided to
   at the factory.  Neither the device nor the network knows if the
   device yet knows if this device belongs with this network.

joined node
: the prospective device, after having completing the join process.

Join Proxy (JP):
:  A signed token from the manufacturer authorized signing
   authority indicating that the bootstrapping event has been
   successfully logged.  This has been referred to as an
   "authorization token" indicating that it authorizes bootstrapping
   to proceed.

join registrar/coordinator:
:  central entity responsible for authentication and authorization of joining nodes.


# Join Overview

This section describes the steps taken by a pledge in a 6TiSCH network.
When a previously unknown device seeks admission to
a 6TiSCH {{RFC7554}} network, the following exchange occurs:

1.  The pledge listens for an Enhanced Beacon (EB) frame
       {{IEEE8021542015}}.  This frame provides network synchronization
       information, and tells the device when it can send a frame to the
       node sending the beacons, which plays the role of Join Assistant
       (JA) for the JN, and when it can expect to receive a frame.
2.  The pledge configures its link-local IPv6 address and advertizes it to Join Proxy (JP).
3.  The JP sends packets to the pledge in order to securely identify itself to the network.
    These packets are directed to the Join Registrar/Coordinator  (JRC),
    which may be co-located on the  JP or another device.
4.  The pledge receives one or more packets from JRC (via the JP) that sets
    up one or more link-layer keys used to authenticate subsequent
    transmissions to peers.

From the joining node's perspective, minimal joining is a local phenomenon â€“
the pledge only interacts with the JP, and it need not know how far it is
from the DAG root, or how to route to the JRC.
Only after establishing one or more link-layer keys does it need to know
about the particulars of a 6TiSCH network.

The handshake is shown as a transaction diagram in {{fig_sequence-diagram}}:

~~~~~~~~~~~
      +-----+               +----------+              +-----------+
      | JRC |               |    JP    |              |  pledge   |
      |     |               |          |              |           |
      +-----+               +----------+              +-----------+
         |                        |                            |
         |                        |-----------ENH BEACON (1)-->|
         |                        |                            |
         |                        |<--Neighbor Discovery (2)-->|
         |                        |                            |
         |<--Sec. Handshake (3a)--|---Security Handshake (3)-->|
         |                        |                            |
         |<----Join request (4a)--|---------Join request (4)---|
         |                        |                            |
         |----Join response (5a)--|--------Join response (5)-->|
         |                        |                            |

~~~~~~~~~~~
{: #fig_sequence-diagram title="Message sequence for join protocol."}
{: artwork-align="center"}

The details of each step are described in the following sections.

## Step 1 - Enhanced Beacon

The pledge hears an EB from the JP and synchronizes itself to the joining
schedule using the cells contained in the EB.
At this point the pledge MAY proceed to step 2, or continue to listen for additional EBs.
If more than one EB is heard, the pledge MAY use a metric based on DAG rank
and received signal level of the EB, or other factors to decide which JP to
use for the security handshake in step 3.
Details on how a pledge chooses the JP are out of scope of this specification.

## Step 2 - Neighbor Discovery

At this point, JN forms its link-local IPv6 address based on EUI64
and MAY further follow the Neighbor Discovery (ND) process described
in Section 5 of [RFC6775].

## Step 3 - Security Handshake

The security handshake between pledge and JRC uses Ephemeral
Diffie-Hellman over COSE (EDHOC) {{I-D.selander-ace-cose-ecdhe}}
to establish the shared session secret used to encrypt the join request and
join response.

The security handshake step is OPTIONAL in case PSKs are used, while it is
REQUIRED for RPKs and certificates. When using certificates, the process
outlined in {{!I-D.ietf-6tisch-dtsecurity-secure-join}} would be followed, and
once complete, the process would continue here with a locally relevant
security, and an established shared secret.

In case the handshake step is omitted, the shared secret used for protection
of the join request and join response in the next step is the PSK.

A consequence is that if the long-term PSK is
compromised, keying material transferred as part of the join response
is compromised as well.
Physical compromise of the pledge, however, would also imply the compromise
of the same keying material, as it is likely to be found in node's memory.

### Pre-Shared Key

The Diffie-Hellman key exchange and the use of EDHOC is optional,
when using a pre-shared symmetric key.
This cuts down on traffic between JRC and pledge, but requires
pre-configuration (one-touch) of the shared key on both devices.

It is REQUIRED to use unique PSKs for each pledge.  If there are multiple
JRC's in the network (such as for redundancy), they would have to share a
database of PSKs.

### Asymmetric Keys

The Security Handshake step is required, when using asymmetric keys.
Before conducting the Diffie-Hellman key exchange using EDHOC {{I-D.selander-ace-cose-ecdhe}}
 the pledge and JRC need to receive and validate each other's public key certificate.
When RPKs are pre-configured at pledge and JRC, they can directly proceed to the handshake.

## Step 4 - Join Request

The join request is sent from the pledge to the JP using the Aloha slot as
described in the EB, and forwarded to the JRC. Which slot the JP uses to
transmit to the JRC is out of scope: some networks may wish to dedicate
specific slots for this join traffic.

The join request is authenticated/encrypted end-to-end using AES-CCM-
16-64-128 algorithm from {{I-D.ietf-cose-msg}} and a key derived from
the shared secret from step 3.
The nonce is derived from the shared secret, the pledge's EUI64 and a
monotonically increasing counter initialized to 0 when first starting.

## Step 5 - Join Response

The join response is sent from the JRC to the pledge through JP that serves as a stateless relay.
Packet containing the join response travels on the path from JRC to JP using
pre-established routes in the network.
The JP delivers it to the pledge using the slot information from the EB.
JP operates as the application-layer proxy and does not keep
any state to relay the message. It uses information sent in the
clear within the join response to decide where to forward to.

The join response is authenticated/encrypted using AES-CCM-16-64-128
algorithm from {{I-D.ietf-cose-msg}} and a key derived from the shared
secret from step 3.

The nonce is derived from the shared secret, pledge's EUI64 and a
monotonically increasing counter matching that of the join request.

The join response contains one or more (per-peer) link-layer key(s) K2 that
the JN will use for subsequent communication. Each K2 that is provided by the
JRC is associated with an 802.15.4 keyid. (In other link-layer technologies,
a different identifier may be substituted)
It optionally also contains an IEEE 802.15.4 short-address
{{IEEE8021542015}} assigned to pledge by JRC.

# Protocol Specification

The join protocol in {{fig_sequence-diagram}} is implemented over Constrained
Application Protocol (CoAP) {{RFC7252}}.
The Pledge plays the role of a CoAP client, JRC the role of a CoAP server,
while JP implements CoAP forward proxy functionality {{RFC7252}}
Since JP is also likely a constrained device, it does not need to implement a
cache but rather process forwarding-related CoAP options and make requests on
behalf of pledge that is not yet part of the network.

Pledge and JRC MUST protect their exchange end-to-end (i.e. through the
proxy) using Object Security of CoAP (OSCOAP)
{{I-D.ietf-core-object-security}}.

## Proxy Operation of Join Proxy (JP)

The pledge designates a JP as a proxy by including in the CoAP requests to
the JP the Proxy-Scheme option with value "coap" (CoAP-to-CoAP proxy).
The pledge MUST include the Uri-Host option with its value set to the
well-known JRC's alias - "6tisch.arpa".
The pledge does not need to learn the actual IPv6 address of JRC at any time
during the join protocol.  The JP knows the address of the JRC, via a
provisioning process that occured when the JP, acting as a pledge, joined.
The initial bootstrap of the DODAG root would require explicit provisioning
of the JRC address.

Note that the CoAP proxy by default keeps state information in order
to forward the response towards the originator of the request.  This
state information comprises CoAP token, but the implementations also
need to keep track of the IPv6 address of the host, as well as the
corresponding UDP source port number.  In the setting where the proxy
is a constrained device, as in the case of JA, this makes it prone to
Denial of Service (DoS) attacks, due to the limited memory.

In order to facilitate a stateless implementation of Join proxying, the
pledge shall encode in the CoAP message the information necessary for the JP
to send the response back - "origin_info".
For this purpose, the pledge uses the "Context Identifier (Cid)" parameter of
OSCOAP's security context structure.
Context Identifier is sent in clear, readable by JP, and MUST be echoed back
in the response from JRC.
This makes it possible to implement JP's CoAP proxy in a stateless manner.
It also allows JRC to look up the right security context for communication with a given pledge.

### Implementation of origin_info

The origin_info is implemented as a CBOR {{RFC7049}} array object
containing:

* EUI64: pledge's EUI64 address
* source_port: pledge's UDP source port (EDNOTE/XXX: Can we fix the source port?)
* token: pledge's CoAP token (EDNOTE: is there a way to get rid of token?)

~~~~~~~~~~~
origin_info = [
    EUI64 : bstr,
    source_port : uint,
    token : uint
]
~~~~~~~~~~~

##  OSCOAP Security Context Instantiation

The OSCOAP security context MUST be derived at pledge and JRC as per Section
3.2 of {{I-D.ietf-core-object-security}} using HKDF {{RFC5869}} as the key
derivation function.

* Context Identifier (Cid) MUST be the origin_info object wrapped as a byte
      string (bstr).  This context information is included in the derivation
      of the shared secret, so while visible, it is protected.
* Algorithm MUST be set to AES-CCM-16-64-128 from
      {{I-D.ietf-cose-msg}}.  CoAP messages are therefore protected with
      an 8-byte CCM authentication tag and the algorithm uses 13-byte
      long nonces.
* Base key (base_key) MUST be the secret generated by the run of
      EDHOC, or the PSK in case EDHOC step was omitted.
* Sender ID of pledge MUST be set to 0x00, while the ID of JRC MUST be set to 0x01.

The hash algorithm that instantiates HKDF MUST be SHA-256 [RFC4231].
The derivation in {{I-D.ietf-core-object-security}} results in traffic
keys and static IVs for each side of the conversation.  Nonces are
constructed by XOR'ing the static IV with current sequence number.
The context derivation process occurs exactly once.

Implementations MUST ensure that multiple CoAP requests to different JRCs
result in the use of the same OSCOAP context so that sequence numbers are
properly incremented for each request.
This may happen in a scenario where there are multiple 6TiSCH networks
present and the pledge tries to join one network at a time.

## Implementation of Join Request

Join Request message SHALL be mapped to a CoAP request:

* The request method is GET.
* The Proxy-Scheme option is set to "coap".
* The Uri-Host option is set to "6tisch.arpa".
* The Uri-Path option is set to "j".
* The object security option SHALL be set according to
  {{I-D.ietf-core-object-security}} and OSCOAP parameters set as
  described above.

## Implementation of Join Response

If OSCOAP processing is a success, Join Response message SHALL be a
CoAP response:

* The response Code is 2.05 (Content).
* The payload is a CBOR array containing, in order:
    *  COSE Key Set {{I-D.ietf-cose-msg}}.  Each key in the Key Set
       SHALL be a symmetric key.  A key that is present in the Key Set
         and does not have an identifier is assumed to be "K2" link-
         layer key from {{I-D.ietf-6tisch-minimal}}.  Parameter "kid" of
         the COSE Key structure SHALL be used to denote pair-wise keys
         if present, where the value SHALL be set to the address of the
         corresponding peer.
    *  Optional byte string representing IEEE 802.15.4 short address
         assigned to pledge.  The short-address includes a lease time.  It is
         used for configuring both L2 short addresses and L3 short
         addresses.

~~~~~~~~~~~
payload = [
    COSE_KeySet,
    ? short_address : bstr,
]
~~~~~~~~~~~

In case JRC determines that pledge is not supposed to join the network
(e.g. by failing to find an appropriate security context), it should respond
with a 4.01 Unauthorized error.
Upon reception of a 4.01 Unauthorized, the pledge SHALL attempt to join the
next advertised 6TiSCH network.
If all join attempts have failed at pledge, the pledge SHOULD signal to the
user by an out-of-band mechanism the presence of an error condition.


# Link-layer requirements

All frames in a 6TiSCH network MUST use link-layer frame security.
The frame security options MUST include frame authentication, and MAY
include frame encryption.

In order for the pledge to be able to validate that the Enhanced Beacon frame
is coming from a 6TiSCH network, EB frames are authenticated at the link
layer using CCM* per {{IEEE8021542015}}
Link-layer frames are protected with a 16-byte key, and a 13-byte nonce
constructed
from current Absolute Slot Number (ASN) and the source (the JA for
EBs) address, as shown in {{fig_ccm-nonce}}:

~~~~~~~~~~~
+-------------------------------------------+
|  Address (8B or 00-padded 2B) | ASN (5B)  |
+-------------------------------------------+
~~~~~~~~~~~
{: #fig_ccm-nonce title="Link-layer CCM* nonce construction" }
{: artwork-align="center"}

The pledge does not initially do any authentication of the EB frames, as it
does not know the K1 key.  When sending packets, the pledge sends unencrypted
and unauthenticated packets (exempt mode in 802.15.4).  How JP learns whether
the join process is ongoing is out of scope of this specification.

As the EB itself cannot be authenticated by pledge, an attacker may craft a
frame that appears to be a valid EB, since the pledge can neither know the
ASN a priori nor verify the address of the JP.
This permits a Denial of Service (DoS) attack at the pledge.
Beacon authentication keys are discussed in {{I-D.ietf-6tisch-minimal}}.

# Asymmetric Keys

Certificates or pre-configured RPKs may be used to exchange public keys
between the pledge and JRC.
The key pair is generated using elliptic curve secp256r1, and
the certificate containing the public key is signed using ECDSA.  (XXX: would
be nice to move to EdDSA)

The certificate itself may be a compact
representation of an X.509 certificate, or a full X.509 certificate.
Compact representation of X.509 certificates is out of scope of this
specification.  The certificate is signed by a root CA whose
certificate is installed on all nodes participating in a particular
6TiSCH network, allowing each node to validate the certificate of the
JCE or JN as appropriate.

# Security Considerations

In case PSKs are used, this document mandates that the pledge and JRC are
pre-configured with unique keys.
The uniqueness of generated nonces is guaranteed under the assumption of
unique EUI64 identifiers for each pledge.
Note that the address of the JRC does not take part in nonce construction.
Therefore, even should an error occur, and a PSK shared by a group of nodes,
the nonces constructed as part of the different responses are unique.  The
PSK is still important for authentication of the pledge and authentication of
the JRC to the pledge. Should an attacker come to know the PSK, then a
man-in-the-middle attack is possible.  The well known problem with Bluetooth
headsets with a "0000" pin applies here.
The design differentiates between nonces constructed for requests and nonces
constructed for responses by different sender identifiers (0x00 for pledge
and 0x01 for JRC).

Being a stateless relay, JP blindly forwards the join traffic into the network.
While the exchange between pledge and JP takes place over a shared cell, join
traffic is forwarded using dedicated cells on the JP to JRC path.
In case of distributed scheduling, the join traffic may therefore cause
intermediate nodes to request additional bandwidth. (EDNOTE: this is a
problem that needs to be solved)
Because the relay operation of JP is implemented at the application layer, JP
is the only hop on the JP-6LBR path that can distinguish join traffic from
regular IP traffic in the network.
It is therefore recommended to implement stateless rate limiting at JP: a
simple bandwidth (in bytes or packets/second) cap would be appropriate.

The shared nature of the "minimal" cell used for join traffic makes the
network prone to DoS attacks by congesting the JP with bogus radio traffic.
As such an attacker is limited by emitted radio power, redundancy in the
number of deployed JPs alleviates the issue and also gives the pledge a
possibility to use the best available link for join.
How a network node decides to become a JP is out of scope of this specification.

At the time of the join, the pledge has no means of verifying the content in
the EB and has to accept it at "face value".
In case the pledge tries to join an attacker's network, the join response
message in such cases will either fail the security check or time out.
The pledge may implement a blacklist in order to filter out undesired beacons
and try to join the next seemingly valid network.
The blacklist alleviates the issue but is effectively
limited by the node's available memory.
Such bogus beacons will prolong the join time of the pledge and so the time
spent in "minimal" {{I-D.ietf-6tisch-minimal}} duty cycle mode.

# Privacy Considerations

This specification relies on the uniqueness of EUI64 that is transferred in
clear as part of the security context identifier. (EDNOTE: should we say IID
here?)
Privacy implications of using such long-term identifier are discussed
in {{RFC7721}} and comprise correlation of activities over time,
location tracking, address scanning and device-specific vulnerability
exploitation.  Since the join protocol is executed rarely compared to
the network lifetime, long-term threats that arise from using EUI64
are minimal.
In addition, the join response message contains an optional short address
which can be assigned by JRC to the pledge.
The short address is independent of the long-term identifier EUI64 and is
encrypted in the response.
For that reason, it is not possible to
correlate the short address with the EUI64 used during the join.  Use
of short addresses once the join protocol completes mitigates the
aforementioned privacy risks.  In addition, EDHOC may be used for
identity protection during the join protocol by generating a random
context identifier in place of the EUI64
{{I-D.selander-ace-cose-ecdhe}}.

# IANA Considerations

There is no IANA action required for this document.

# Acknowledgments

The work on this document has been partially supported by the
European Union's H2020 Programme for research, technological
development and demonstration under grant agreement No 644852,
project ARMOUR.

The authors are grateful to Thomas Watteyne and Goeran Selander for
reviewing the draft.  The authors would also like to thank Francesca
Palombini and Ludwig Seitz for participating in the discussions that
have helped shape the document.

--- back

# Example

{{fig_example-psk}} illustrates a join protocol exchange in case PSKs are used.
JN instantiates the OSCOAP context and derives the traffic keys and
nonces from the PSK.  It uses the instantiated context to protect the
CoAP request addressed with Proxy-Scheme option and well-known host
name of JCE in the Uri-Host option.  The example assumes a JA that is
already aware of JCE's IPv6 address and does not need to resolve the
well-known "6tisch.jce" host name.  Triggered by the presence of
Proxy-Scheme option, JA forwards the request to the JCE.  Once JCE
receives the request, it looks up the correct context based on the
context identifier (cid) field.  It reconstructs OSCOAP's external
Additional Authenticated Data (AAD) needed for verification based on:

* Version field of the received CoAP header.
* Code field of the received CoAP header.
* Algorithm being the AES-CCM-16-64-128 from {{I-D.ietf-cose-msg}}
* Request URI reconstructed following
      {{I-D.ietf-core-object-security}}.

Replay protection is ensured by OSCOAP and the tracking of sequence
numbers at each side.  In the example below, the response contains
sequence number 7 meaning that there have already been some attempts
to join under a given context, not coming from the JN.  Once JA
receives the response, it looks up and decodes the cid field in order
to decide where to forward it.  JA constructs the CoAP response to JN
by setting the CoAP token to the value decoded from cid and
constructs the link-local IPv6 address of JN from the EUI64 address
found in the cid.  Note that JA does not posses the key to decrypt
the COSE object present in the payload so the join_response object is
opaque to it.  The response is matched to the request and verified
for replay protection at JN using OSCOAP processing rules.  Namely,
to verify the response JN reconstructs the AAD based on:

* Version field of the received CoAP header.
* Code field of the received CoAP header.
* Algorithm being the AES-CCM-16-64-128 from {{I-D.ietf-cose-msg}}.
* Transaction identifier (Tid) of the corresponding CoAP request.
      Tid contains the context identifier (origin_info object), Sender
      ID (0x00 for JN), and Sender Sequence number (set to 1 in the
      example).

In addition to AAD, JN also uses the explicit, protected fields in
the COSE message, present in the payload of the response.  For more
details, see {{I-D.ietf-core-object-security}} and {{I-D.ietf-cose-msg}}.

~~~~~~~~~~~
<--E2E OSCOAP-->
Client  Proxy Server
JN     JA     JCE
|      |      |
+----->|      |            Code: [0.01] (GET)
| GET  |      |           Token: 0x8c
|      |      |    Proxy-Scheme: [coap]
|      |      |        Uri-Host: [6tisch.jce]
|      |      | Object-Security: [cid:origin_info, seq:1,
|      |      |                   {Uri-Path:"j"},
|      |      |                   <Tag>]
|      |      |         Payload: -
|      |      |
|      +----->|            Code: [0.01] (GET)
|      | GET  |           Token: 0x7b
|      |      |        Uri-Host: [6tisch.jce]
|      |      | Object-Security: [cid:origin_info, seq:1,
|      |      |                   {Uri-Path:"j"},
|      |      |                   <Tag>]
|      |      |         Payload: -
|      |      |
|      |<-----+            Code: [2.05] (Content)
|      | 2.05 |           Token: 0x7b
|      |      | Object-Security: -
|      |      |         Payload: [cid: origin_info, seq:7,
|      |      |                   {join_response}, <Tag>]
|      |      |
|<-----+      |            Code: [2.05] (Content)
| 2.05 |      |           Token: 0x8c
|      |      | Object-Security: -
|      |      |         Payload: [cid: origin_info, seq:7,
|      |      |                   {join_response}, <Tag>]
|      |      |
~~~~~~~~~~~
{: #fig_example-psk title="Example of a join protocol exchange with a PSK. {\} denotes encryption and authentication, [] denotes authentication." }
{: artwork-align="center"}

Where origin_info and join_response are as follows.

~~~~~~~~~~~
origin_info:
[
    h'00170d00060d9f0e', / JN's EUI64 /
    49152, / JN's UDP source port /
    0x8c   / JN's CoAP token /
]
~~~~~~~~~~~

Encodes to h'834800170d00060d9f0e19c000188c' with a size of 15 bytes.

~~~~~~~~~~~
join_response:
[
    [   / COSE Key Set array with a single key /
        {
            1:4, / key type symmetric /
            -1:h'e6bf4287c2d7618d6a9687445ffd33e6' / key value /
        }
    ],
    h'af93' / assigned short address /
]
~~~~~~~~~~~

Encodes to h'8281a201042050e6bf4287c2d7618d6a9687445ffd33e642af93'
with a size of 26 bytes.

